{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Card Action API","text":"<p>Welcome to the Card Action API \u2014 a secure, efficient, and extensible solution for determining allowed actions on Credit, Debit, and Prepaid banking cards.</p> <p>Built with production standards in mind: - Modern, modular architecture (.NET 8) - Strong validation and security by default - Flexible configuration for any environment - Fully tested and ready for real-world integration</p> <p>This project was created for a technical recruitment process, but delivers everything you'd expect from a professional-grade API.</p> <p>In this documentation you will find: - Step-by-step usage instructions - Complete architecture breakdown - Request/response examples - Configuration and deployment tips</p> <p>Get started below and discover how to integrate, test, and extend the Card Action API for your needs.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>The API is designed to meet real-world standards for banking systems, with the following core requirements:</p> <ul> <li>Expose a REST endpoint that returns allowed actions for a banking card based on its type, status, and flags</li> <li>Enforce input validation and consistent error responses</li> <li>Require API key authentication</li> <li>Use matrix-driven business logic, fully separated from infrastructure</li> <li>Support multiple environments (Development, Staging, Production)</li> <li>Apply clean, layered architecture (API, Application, Domain, Infrastructure)</li> <li>Include comprehensive unit and integration test coverage</li> <li>Provide documentation (Swagger, MkDocs)</li> <li>Enable easy deployment and containerization (Docker support)</li> </ul> <p>These requirements ensure the API is robust, secure, and easy to extend or adapt to production needs.</p>"},{"location":"FAQ/","title":"FAQ","text":"<p>Q: How do I change or add matrix rules? A: Edit the rules in <code>Domain/Providers/MatrixProvider.cs</code> or extend the logic in <code>CardResolver</code>. All matrix logic is separated and fully testable.</p> <p>Q: Where do I configure the data source? A: Data providers are in <code>Infrastructure/Data</code>. By default, the project uses <code>SampleCardDataProvider</code>. You can swap to SQL or Kafka by changing DI or configuration.</p> <p>Q: How does API authentication work? A: Every API call requires the <code>X-API-KEY</code> header. Requests without a valid key return HTTP 401 Unauthorized.</p> <p>Q: How do I add a new card action or status? A: Extend the appropriate enums in <code>Domain/Enums</code> and update the matrix rules in <code>MatrixProvider.cs</code>.</p> <p>Q: How is environment-specific behavior handled? A: The project uses environment variables and <code>appsettings.*.json</code> files to inject different data providers and settings at runtime.</p> <p>Q: How do I enable or change logging? A: Logging is configured via Serilog in <code>Program.cs</code> and can be customized in the <code>appsettings.*.json</code> files.</p> <p>Q: What should I change for production deployment? A: Use a real data provider, configure <code>appsettings.Production.json</code>, set a secure API key, and configure monitoring/logging if needed.</p> <p>Q: How is error handling managed? A: All errors are returned using standardized <code>ProblemDetails</code> responses via custom middleware.</p> <p>Q: How do I update API versioning? A: API versioning is set up in the controllers and Swagger configuration. Update versions in the route attributes and Swagger as needed.</p>"},{"location":"Summary/","title":"Summary","text":"<p>This project delivers:</p> <ul> <li>Modular .NET 8 API for resolving allowed actions on bank cards</li> <li>Strict input validation and API key security</li> <li>Matrix-driven business logic, cleanly separated from infrastructure</li> <li>Environment-based DI: easily swap services and providers per environment</li> <li>Comprehensive testing: unit and integration coverage for all layers</li> <li>Automatic API docs via Swagger UI</li> <li>Container-ready: Docker support for easy deployment</li> </ul> <p>The solution is designed for clarity, extensibility, and easy adaptation to real-world banking scenarios.</p>"},{"location":"Architecture/API%20Layer/","title":"API Layer","text":"<ul> <li> <p><code>CardController</code> exposes a single HTTP GET endpoint:   <code>/api/v1/Card?UserId=abc&amp;CardNumber=xyz</code></p> </li> <li> <p>Incoming request is validated via FluentValidation.</p> </li> <li>Card data is fetched from an injected provider (SQL, Kafka, or Sample).</li> <li>Card actions are resolved through <code>CardResolver</code>.</li> <li>Response is returned in JSON array format (e.g., <code>[\"ACTION1\", \"ACTION3\"]</code>).</li> </ul> <p>Authorization header required: ```text X-API-KEY: test-key</p>"},{"location":"Architecture/Application%20Layer/","title":"Application Layer","text":"<ul> <li>ICardService</li> <li>ICardResponseFactory</li> <li>ICardResolver</li> <li>IMatrixProvider</li> <li>ICardDataProvider</li> </ul> <p>Implements all business logic and interfaces, with no hard dependencies on infrastructure.</p>"},{"location":"Architecture/Containerization/","title":"Containerization","text":"<ul> <li><code>Dockerfile</code> \u2014 basic template for building a container image of the API</li> <li><code>compose.yaml</code> \u2014 example for running the API using Docker Compose</li> <li><code>.dockerignore</code> \u2014 defines which files and folders are excluded from the container build</li> </ul> <p>The API is ready for containerized environments out of the box. You can run it locally, in the cloud, or integrate with CI/CD using these templates.</p> <p>No advanced Docker configuration is required for this project. The provided files are clean and simple, and can be easily extended as needed.</p>"},{"location":"Architecture/Domain%20Layer/","title":"Domain Layer","text":"<ul> <li>Core enums: <code>CardType</code>, <code>CardStatus</code>, <code>EnActionFlag</code></li> <li>Main domain model: <code>CardDetails</code></li> <li>Matrix rules and action definitions for card operation logic</li> <li>Exception types and pure-value objects</li> </ul> <p>This layer holds all domain logic and definitions. No runtime behavior, no external dependencies \u2014 only business rules and structures.</p>"},{"location":"Architecture/Implementation%20Details/","title":"Implementation Notes","text":"<ul> <li>All core services and data providers are injected using environment-based dependency injection, allowing dynamic configuration for development, staging, and production.</li> <li>The <code>Program.cs</code> is organized with <code>#region</code> blocks for each startup area (middleware, logging, services, security, swagger), making startup logic clear and easy to extend.</li> <li>Error responses are standardized using <code>ProblemDetails</code>, ensuring consistent API error contracts.</li> <li>Middleware is registered in a secure, logical order: correlation and logging first, then exception handling, API key validation, and finally endpoint routing.</li> </ul>"},{"location":"Architecture/Infrastructure%20Layer/","title":"Infrastructure Layer","text":"<ul> <li>CardResolver</li> <li>CardService</li> <li>SqlCardDataProvider</li> <li>KafkaCardDataProvider</li> <li>SampleCardDataProvider</li> <li>CardDataMapper</li> <li>Middleware (ApiKey, Exception, CorrelationId)</li> </ul> <p>Well-separated and testable.</p>"},{"location":"Architecture/Modules/","title":"Helper Modules","text":"<ul> <li>FluentValidation \u2013 request and model validation</li> <li>Serilog \u2013 structured logging for the whole application</li> <li>CorrelationId \u2013 adds and logs correlation IDs for every request</li> <li>IP Rate Limiting \u2013 restricts API usage per client IP</li> </ul> <p>All modules are fully configured in <code>Program.cs</code>: - Registered as middleware in the pipeline - Logging and validation rules set up at startup - Security (API key, rate limits) enforced before business logic</p>"},{"location":"Architecture/Solution%20Structure/","title":"Solution Structure","text":""},{"location":"Architecture/Solution%20Structure/#src","title":"/src","text":"<ul> <li>Api (Controllers, Requests, Responses)</li> <li>Application (Contracts, Interfaces)</li> <li>Domain (Enums, Models, Parsers, Providers, Validators, Mappers, Exceptions)</li> <li>Infrastructure (Data Providers, Services, Middleware, Mappers)</li> <li>Configuration (API behavior, Logging, Security, Swagger)</li> <li>Properties (launchSettings.json)</li> </ul>"},{"location":"Architecture/Solution%20Structure/#tests","title":"/tests","text":"<ul> <li>Unit and integration tests for all features and middlewares</li> </ul>"},{"location":"Architecture/Solution%20Structure/#docs","title":"/docs","text":"<ul> <li>MkDocs documentation (Markdown files, config, custom CSS)</li> </ul>"},{"location":"Architecture/Solution%20Structure/#root-files","title":"Root files","text":"<ul> <li>Program.cs (entry point)</li> <li>appsettings.*.json (environment config)</li> <li>Dockerfile, compose.yaml (containerization)</li> </ul> <p>Environment-specific providers (e.g., CardDataProvider) are injected at runtime using configuration.</p>"},{"location":"Architecture/System%20Architecture/","title":"Architecture","text":""},{"location":"Architecture/System%20Architecture/#api","title":"API","text":"<ul> <li>Controllers (CardController)</li> <li>Requests (input DTOs + validation)</li> <li>Responses (output DTOs)</li> </ul>"},{"location":"Architecture/System%20Architecture/#application","title":"Application","text":"<ul> <li>Contract (CardResponse, CardSummary)</li> <li>Interfaces (ICardService, ICardResolver, ICardDataProvider, ICardResponseFactory, IMatrixProvider)</li> </ul>"},{"location":"Architecture/System%20Architecture/#domain","title":"Domain","text":"<ul> <li>Enums (EnActionFlag, EnCardType, EnCardStatus)</li> <li>Exceptions (DomainValidationException)</li> <li>Mappers (ActionFlagMapper)</li> <li>Models (CardDetails)</li> <li>Parsers (MatrixParser)</li> <li>Providers (MatrixProvider)</li> <li>Validators (MatrixValidator)</li> </ul>"},{"location":"Architecture/System%20Architecture/#infrastructure","title":"Infrastructure","text":"<ul> <li>Data providers (KafkaCardDataProvider, SqlCardDataProvider, SampleCardDataProvider + DTOs)</li> <li>Mappers (CardDataMapper)</li> <li>Middleware (ApiKeyMiddleware, CorrelationIdLoggingMiddleware, IssueHandlingMiddleware)</li> <li>Services (CardService, CardResolver, CardResponseFactory)</li> </ul>"},{"location":"Architecture/System%20Architecture/#configuration","title":"Configuration","text":"<ul> <li>API behavior (ConfigureApiBehavior)</li> <li>Logging (LoggingSetup, LogPathResolver)</li> <li>Security (KeyOption)</li> <li>Swagger (ConfigureSwaggerOptions)</li> </ul>"},{"location":"Architecture/System%20Architecture/#testing","title":"Testing","text":"<ul> <li><code>/tests</code> \u2014 unit and integration tests (CardResolverTests, ApiKeyMiddlewareTests, etc.)</li> </ul>"},{"location":"Architecture/System%20Architecture/#other","title":"Other","text":"<ul> <li><code>appsettings.*.json</code> \u2014 environment config</li> <li><code>launchSettings.json</code> \u2014 run/debug profiles</li> <li><code>Dockerfile</code>, <code>compose.yaml</code> \u2014 containerization</li> <li><code>Program.cs</code> \u2014 entry point</li> </ul>"},{"location":"Project/Building/","title":"How to Run the API","text":""},{"location":"Project/Building/#clone-the-repository","title":"Clone the Repository","text":"<p>Open your terminal and run the following command:</p> <pre><code>git clone &lt;repository_URL&gt;\n</code></pre>"},{"location":"Project/Building/#launch-the-project","title":"Launch the Project","text":"<p>Use your IDE or run:</p> <pre><code>dotnet run --project src\n</code></pre> <p>Optional: run tests beforehand</p> <pre><code>dotnet test\n</code></pre>"},{"location":"Project/Building/#test-the-api","title":"Test the API","text":"<p>Once running, open your browser and navigate to:</p> <pre><code>https://localhost:5001/swagger\n</code></pre> <p>Swagger UI allows you to explore and test all available endpoints.</p>"},{"location":"Project/How/","title":"How Does It Work?","text":"<p>Client provides:</p> <ul> <li><code>UserId</code> (required, query param)</li> <li><code>CardNumber</code> (required, query param)</li> <li>API key in header: <code>X-API-KEY</code></li> </ul> <p>System returns:</p> <ul> <li>List of allowed actions for the card</li> <li>Card details used in resolution</li> </ul> <p>Notes:</p> <ul> <li>Authorize in Swagger UI (\"Authorize\" button) using your API key.</li> <li>Each request returns actions for one specific card only.</li> <li>Missing or invalid API key = HTTP 401.</li> <li>Card not found = HTTP 404.</li> <li>All logic is handled by <code>CardResolver</code> and matrix rules.</li> </ul> <p>Example:</p> <ul> <li><code>UserId</code>: <code>User1</code></li> <li><code>CardNumber</code>: <code>Card12</code> or <code>Card121</code></li> </ul> <p>If User1 owns multiple cards (e.g. <code>Card12</code>, <code>Card121</code>), you get actions only for the card you specify in the request. Other cards for the same user are not affected or returned.</p> <p>How to test in Swagger:</p> <ul> <li>Go to <code>/swagger</code></li> <li>Click Authorize and enter your API key</li> <li>Use GET <code>/api/v1/card</code> with <code>UserId</code> (e.g. <code>User1</code>) and <code>CardNumber</code> (e.g. <code>Card12</code>)</li> </ul>"},{"location":"Project/Introduction/","title":"Project Objective","text":"<p>The system exposes a banking API that resolves allowed actions based on card type, status and PIN availability.</p>"},{"location":"Project/Introduction/#key-features","title":"Key Features","text":"<ul> <li>Card data resolved from injected provider (mock/sql/kafka)</li> <li>Matrix-based action rule engine</li> <li>Secure endpoint access (API Key)</li> <li>Validation via FluentValidation</li> <li>Fast response and high readability</li> </ul>"},{"location":"Project/Introduction/#context","title":"Context","text":"<p>Developed during the technical recruitment process as a standalone card logic resolver. Focus was put on clean architecture, environment configuration and real-world middleware handling.</p>"},{"location":"Testing/Perf/","title":"Performance Notes","text":"<ul> <li>All in-memory matrix lookups</li> <li>No DB roundtrips unless real provider used</li> <li>Dependency resolution scoped and cached</li> </ul>"},{"location":"Testing/Security/","title":"Security","text":""},{"location":"Testing/Security/#api-key-authentication","title":"API Key Authentication","text":"<ul> <li>Every request must include a valid <code>X-API-KEY</code> header.</li> <li>Requests without it return HTTP 401 Unauthorized.</li> </ul>"},{"location":"Testing/Security/#middleware-safeguards","title":"Middleware Safeguards","text":"<ul> <li>Custom middleware validates the API key.</li> <li><code>ProblemDetailsMiddleware</code> handles error formatting and HTTP codes.</li> <li>IP rate limiting prevents abuse and DDoS scenarios.</li> <li><code>CorrelationIdMiddleware</code> assigns a unique ID per request for logging/tracing.</li> <li> <p>HTTP headers are hardened with:</p> </li> <li> <p><code>X-Content-Type-Options: nosniff</code></p> </li> <li><code>X-Frame-Options: DENY</code></li> <li><code>X-XSS-Protection: 1; mode=block</code></li> <li><code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code></li> <li><code>Referrer-Policy: no-referrer</code></li> <li><code>Permissions-Policy: geolocation=(), microphone=()</code></li> </ul>"},{"location":"Testing/Security/#testing-coverage","title":"Testing Coverage","text":"<ul> <li>Unit and integration tests validate both authorized and unauthorized access.</li> <li>API key checks and error responses are fully testable and verified.</li> </ul>"},{"location":"Testing/Security/#example-header","title":"Example Header","text":"<pre><code>X-API-KEY: test-key\n</code></pre>"},{"location":"Testing/Testing/","title":"Testing Overview","text":"<p>Tests are organized into:</p>"},{"location":"Testing/Testing/#unit-tests","title":"Unit Tests","text":"<ul> <li>Validate matrix logic (<code>CardResolver</code>, rule evaluation)</li> <li>Lightweight, fast feedback cycle</li> </ul>"},{"location":"Testing/Testing/#integration-tests","title":"Integration Tests","text":"<ul> <li>Cover middleware behavior and full request/response flow</li> <li>Validate security layers, headers, and error responses</li> </ul>"},{"location":"Testing/Testing/#stack","title":"Stack","text":"<ul> <li>Framework: xUnit</li> <li>Mocking: Moq</li> <li>Setup: Custom <code>WebApplicationFactory</code></li> </ul> <p>Test coverage ensures all critical paths and edge cases are verified automatically.</p>"}]}